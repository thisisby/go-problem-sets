package main

import (
	"fmt"
	"sync"
)

func main() {
	urls := make([]string, 10000000) // тут у нас все 10 млн ссылок
	codes := make(map[int]int)       // в эту мапу нужно писать

	mu := sync.Mutex{} // создаем мьютекс для параллельной работы с мапой

	ch := make(chan string) // создаем канал, из которого наши воркеры будут брать горутины
	go func() {             // здесь создаем отправителя задач в этот канал
		for _, url := range urls { // обходим все ссылки
			ch <- url // пушим каждую в канал. канал небуф, поэтому эта горутина ->
			// закончит работу, когда все юрлы будут прочитаны. Подробнее про это
			// я расскажу в следующих постах
		}
		close(ch) // закрываем канал, потому что все юрлы уже дошли воркерам
	}()

	const workersCount = 5 // наше кол-во параллельно запускаемых воркеров
	wg := sync.WaitGroup{} // вэйтгруппа, чтобы дождаться обработки всех юрлов

	wg.Add(workersCount) // сразу добавляем в вэйтгруппу все горутины
	for _ = range workersCount {
		go func() { // создаем workersCount горутин-воркеров, которые будут обрабатывать
			// наши юрлы, которые им будет отправлять горутина на 11 строке
			defer wg.Done()       // сообщаем, что воркер завершил работу, потому что канал закрылся
			for url := range ch { // особый синтаксис обхода по каналу, произойдет break, когда канал закроется
				code := sendRequest1(url) // кидаем запрос
				// важно это делать до мьютекса, чтобы у нас воркеры делали запросы параллельно

				mu.Lock()
				codes[code]++ // потокобезопасно записываем в мапу инкремент
				mu.Unlock()
			}
		}()
	}

	wg.Wait()          // дожидаемся окончания работы всех воркеров
	fmt.Println(codes) // выводим результат
}

// sendRequest Тут мы инкасулировали логику работы с протоколом HTTP, писать тут ничего не нужно
func sendRequest1(url string) (code int) {
	// do smth

	return 200
}
