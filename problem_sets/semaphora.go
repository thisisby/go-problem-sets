package main

import (
	"fmt"
	"sync"
)

func main() {
	urls := make([]string, 10000000) // тут у нас все 10 млн ссылок
	codes := make(map[int]int)       // в эту мапу нужно писать

	// тут код
	semaphora := make(chan struct{}, 5) // создаем буф канал с пустой структурой,
	// потому что ничего не планируем через него передавать, a struct{} весит
	// 0 байт. буфером 5 допускаем возможность запуска параллельно пяти горутин - смотри дальше

	mu := sync.Mutex{} // для параллельной работы с мапой

	for _, url := range urls { // обходим все юрлы
		semaphora <- struct{}{} // тут заполняем буфер на один элемент
		// таким образом в какой-то момент наша горутина main уйдет в вэйтинг -
		// т.е. дальше ничего не будет создаваться, пока из канала кто-то не прочитает
		// что-то и не высвободит одно место
		go func() { // создаем нашу горутинку
			code := sendRequest2(url) // тут есть интересный момент с прокидыванием url, связанный с замыканием
			// про это я расскажу в следующих постах. на версии 1.22+ оно будет работать

			mu.Lock()
			codes[code]++ // потокобезопасно записываем в мапу инкремент
			mu.Unlock()

			<-semaphora // высвобождаем место в буфере, давая возможность выйти из вэйтинга на строке 16 и
			// создать новую горутину
		}()
	}

	fmt.Println(codes) // результат тут
}

// sendRequest Тут мы инкасулировали логику работы с протоколом HTTP, писать тут ничего не нужно
func sendRequest2(url string) (code int) {
	// do something

	return 200
}
